import { S3Client } from '@aws-sdk/client-s3';
import { BedrockRuntimeClient } from '@aws-sdk/client-bedrock-runtime';
import type { Logger } from '@aws-lambda-powertools/logger';
import type { ReportTemplateData } from '../../functions/generate-report/resource';
import type { TemplateEngine } from './template-engine';

export interface ReportGeneratorConfig {
  s3Client: S3Client;
  bedrockClient: BedrockRuntimeClient;
  enableAIInsights: boolean;
  logger: Logger;
}

/**
 * ReportGenerator handles the creation of various report formats
 */
export class ReportGenerator {
  constructor(private config: ReportGeneratorConfig) {}

  /**
   * Generate PDF report
   */
  async generatePDF(
    data: ReportTemplateData,
    reportType: string,
    templateEngine: TemplateEngine
  ): Promise<Buffer> {
    try {
      // Render HTML template
      const htmlContent = await templateEngine.renderTemplate(reportType, data);

      // Use puppeteer to generate PDF (requires puppeteer layer)
      const puppeteer = await import('puppeteer-core');
      
      const browser = await puppeteer.launch({
        executablePath: '/opt/bin/chromium',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--no-first-run',
          '--no-zygote',
          '--single-process',
        ],
        headless: true,
      });

      const page = await browser.newPage();
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });

      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '1cm',
          right: '1cm',
          bottom: '1cm',
          left: '1cm',
        },
      });

      await browser.close();

      this.config.logger.info('PDF report generated successfully', {
        reportType,
        size: pdfBuffer.length,
      });

      return Buffer.from(pdfBuffer);
    } catch (error) {
      this.config.logger.error('Error generating PDF report:', { error });
      throw error;
    }
  }

  /**
   * Generate Excel report
   */
  async generateExcel(data: ReportTemplateData, reportType: string): Promise<Buffer> {
    try {
      const ExcelJS = await import('exceljs');
      const workbook = new ExcelJS.Workbook();

      // Create summary worksheet
      const summarySheet = workbook.addWorksheet('Summary');
      this.createSummarySheet(summarySheet, data);

      // Create findings worksheet
      const findingsSheet = workbook.addWorksheet('Findings');
      this.createFindingsSheet(findingsSheet, data);

      // Create charts worksheet if enabled
      if (data.charts) {
        const chartsSheet = workbook.addWorksheet('Charts');
        this.createChartsSheet(chartsSheet, data);
      }

      const buffer = await workbook.xlsx.writeBuffer();

      this.config.logger.info('Excel report generated successfully', {
        reportType,
        size: buffer.byteLength,
      });

      return Buffer.from(buffer);
    } catch (error) {
      this.config.logger.error('Error generating Excel report:', { error });
      throw error;
    }
  }

  private createSummarySheet(sheet: any, data: ReportTemplateData): void {
    // Add title
    sheet.addRow(['Cloud Best Practice Analysis Report']);
    sheet.addRow([]);

    // Add report info
    sheet.addRow(['Report Information']);
    sheet.addRow(['Title:', data.reportInfo.title]);
    sheet.addRow(['Type:', data.reportInfo.type]);
    sheet.addRow(['Generated:', data.reportInfo.generatedAt]);
    sheet.addRow(['Generated By:', data.reportInfo.generatedBy]);
    sheet.addRow([]);

    // Add project info
    sheet.addRow(['Project Information']);
    sheet.addRow(['Tenant:', data.tenant.name]);
    sheet.addRow(['Project:', data.project.name]);
    sheet.addRow(['Description:', data.project.description || 'N/A']);
    sheet.addRow([]);

    // Add analysis info
    sheet.addRow(['Analysis Information']);
    sheet.addRow(['Analysis Name:', data.analysis.name]);
    sheet.addRow(['Analysis Type:', data.analysis.type]);
    sheet.addRow(['Status:', data.analysis.status]);
    sheet.addRow(['Started:', data.analysis.createdAt]);
    sheet.addRow(['Completed:', data.analysis.completedAt || 'N/A']);
    sheet.addRow([]);

    // Add summary statistics
    sheet.addRow(['Summary Statistics']);
    sheet.addRow(['Total Resources:', data.summary.totalResources]);
    sheet.addRow(['Total Findings:', data.summary.totalFindings]);
    sheet.addRow(['Compliance Score:', `${data.summary.complianceScore || 0}%`]);
    sheet.addRow(['Risk Level:', data.summary.riskLevel || 'Unknown']);
    sheet.addRow([]);

    // Add findings by severity
    sheet.addRow(['Findings by Severity']);
    Object.entries(data.summary.findingsBySeverity).forEach(([severity, count]) => {
      sheet.addRow([severity, count]);
    });
    sheet.addRow([]);

    // Add findings by pillar
    sheet.addRow(['Findings by Well-Architected Pillar']);
    Object.entries(data.summary.findingsByPillar).forEach(([pillar, count]) => {
      sheet.addRow([pillar.replace(/_/g, ' '), count]);
    });
  }

  private createFindingsSheet(sheet: any, data: ReportTemplateData): void {
    // Add headers
    const headers = [
      'ID',
      'Title',
      'Severity',
      'Pillar',
      'Resource',
      'Category',
      'Rule ID',
      'Description',
      'Recommendation',
    ];
    sheet.addRow(headers);

    // Style headers
    const headerRow = sheet.getRow(1);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    };

    // Add findings data
    data.findings.forEach(finding => {
      sheet.addRow([
        finding.id,
        finding.title,
        finding.severity,
        finding.pillar.replace(/_/g, ' '),
        finding.resource,
        finding.category || 'N/A',
        finding.ruleId || 'N/A',
        finding.description,
        finding.recommendation,
      ]);
    });

    // Auto-size columns
    sheet.columns.forEach((column: any) => {
      column.width = 20;
    });

    // Set description and recommendation columns to wrap text
    sheet.getColumn(8).alignment = { wrapText: true };
    sheet.getColumn(9).alignment = { wrapText: true };
  }

  private createChartsSheet(sheet: any, data: ReportTemplateData): void {
    if (!data.charts) return;

    sheet.addRow(['Charts and Visualizations']);
    sheet.addRow([]);

    // Add severity distribution
    sheet.addRow(['Findings by Severity']);
    data.charts.severityDistribution.forEach(item => {
      sheet.addRow([item.label, item.value]);
    });
    sheet.addRow([]);

    // Add pillar distribution
    sheet.addRow(['Findings by Well-Architected Pillar']);
    data.charts.pillarDistribution.forEach(item => {
      sheet.addRow([item.label, item.value]);
    });
  }
}